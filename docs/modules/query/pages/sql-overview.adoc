= SQL Queries
:description: You can use SQL to query data in maps, Kafka topics, or the cluster's local file system. Learn the essentials of SQL in Hazelcast.

{description}

== Using SQL

To use SQL, you have the following options, all of which support all <<supported-queries, query types>>:

- For fast prototyping, xref:pipelines:learn-sql.adoc[use the SQL shell].

- For Java applications, link:https://hazelcast.com/blog/jdbc-driver-4-2-is-released/[use the JDBC driver] or the link:https://docs.hazelcast.org/docs/{page-latest-supported-java-client}/javadoc[Java client].

- For other applications, use either the link:http://hazelcast.github.io/hazelcast-nodejs-client/api/{page-latest-supported-nodejs-client}/docs/[Node.js], or link:https://hazelcast.readthedocs.io/en/v{page-latest-supported-python-client}/index.html[Python] client.
+
WARNING: These clients don't yet support `DATE`, `TIMESTAMP`, or `TIMESTAMP_WITH_TIME_ZONE` xref:sql:data-types.adoc[data types].

NOTE: You cannot run SQL queries on xref:ROOT:glossary.adoc#lite-member[lite members]. This limitation will be removed in future releases.

== Supported Queries

With SQL you can run various types of queries to get insight from your data:

- Ad-hoc queries, also known as point queries or online transactional processing (OLTP) queries.
- Batch queries, also known as online analytical processing (OLAP) queries.
- Streaming queries, also known as continuous queries.
- Federated queries

NOTE: For custom queries, you can build a data pipeline, using the xref:pipelines:building-pipelines.adoc[Java Jet API].

== Connectors

With SQL, you can use xref:pipelines:sources-sinks.adoc[connectors] to access data in Apache Kafka, your cluster's local file system, and any distributed maps on a local cluster.

Connectors allow Hazelcast to recognize a source's data model, data access patterns, and serialization formats. Hazelcast uses these connectors to access resources in these data sources as if they were SQL tables.

To set up and configure connectors, use the xref:sql:create-mapping.adoc[`CREATE MAPPING` statement].

== Schemas

The SQL service exposes objects as tables in the following predefined schemas.

- `partitioned`: For querying existing maps in a local cluster.

- `public`: For querying data with connectors.

If you don't name a schema in your query, Hazelcast first looks in the `public` schema and then in the `partitioned` schema.

You can access data with or without the schema name. Schema names, table names, and field names are case-sensitive.

For example, you can access an exisiting `employee` map
as `employee` or `partitioned.employee`, but not as `Employee`:

[source,sql]
----
SELECT * FROM employee
SELECT * FROM partitioned.employee
----

== Limitations

SQL has the following limitations:

- Jet engine must be enabled.
+
For details about enabling/disabling the Jet engine, see xref:pipelines:job-security.adoc[].

- No window functions.
+
You cannot group or aggregate results in streaming queries.
- Fewer sources and sinks.
+
You can use only a subset of the available sources and sinks in the Jet API.
+
See xref:pipelines:sources-sinks.adoc[].
- Limited support for joins.
+
If you want to use joins, the data source on the right of the join must be a map.
+
See xref:sql:select.adoc#join-tables[Join Tables].

== Supported Statements

Hazelcast supports a subset of standard ANSI SQL statements as well as some custom ones for creating jobs, streaming queries, and connecting Hazelcast to other data platforms.

For a list of supported statements, see xref:sql:sql-statements.adoc[].

== How Hazelcast Executes SQL Statements

When an SQL statement is submitted for execution, the SQL service parses and
optimizes it using link:https://calcite.apache.org/[Apache Calcite]. The result is an executable plan that
is cached and reused by subsequent executions of the same statement.

The plan contains a tree of query fragments. A query fragment is a tree of
operators that could be executed on a single member independently. Child
fragments supply data to parent fragments, possibly over a network, until
the root fragment is reached. The root fragment returns the query results.

== Next Steps

xref:get-started-sql.adoc[Get started] with SQL queries.

See more examples of the xref:sql:select.adoc[`SELECT` statement].
