= Querying Maps with SQL
:description: Use SQL to run optimized distributed queries on the keys and values of maps in a local cluster.
:page-aliases: query:querying-maps-sql.adoc

{description}

== When to Create a Mapping

Depending on the state of existing maps in a local cluster, you may need to xref:mapping-to-maps.adoc[create a mapping] before being able to query their entries in SQL.

You can query existing map entries in a local Hazelcast cluster without creating a mapping only if they fulfil the following conditions:

- Maps contain at least one entry on each member.
+
To resolve the values in an existing map, Hazelcast reads a random entry from one local member. If an entry isn't found, the query fails.
+
WARNING: To avoid query failures, make sure that all objects contain the same fields .
- Entries do not include JSON fields.

If your map does not fulfil these conditions or if you want to create a new map, you must use the map connector to create a mapping to it before you can query it.

== Querying Primitive Entries

A map entry consists of a key and a value. You can query the key through the `__key` alias and the value through the `this` alias.

For example, if you have an map named `capital_cities`, you can query that map, using the following `SELECT` statement.

[source,sql]
----
SELECT * FROM capital_cities;
----

```
+--------------------+------------+
|     __key          |    this    |
+--------------------+------------+
|        1           |   Tokyo    |
+--------------------+------------+
```

The `this` alias is returned by a query only if the value does not contain an object. For example, if the `capital_cities` value was a serialized object that had a `name` and a `country` field, the query result would include those fields as columns and exclude the `this` column.

```
+--------------------+------------+--------------+
|     __key          |    name    |   country    |
+--------------------+------------+--------------+
|        1           |   Tokyo    |    Japan     |
+--------------------+------------+--------------+
```

== Querying Objects in Map Entries

If you store objects in a map, you can query the objects' fields only if they are serialized using one of the following options:

- xref:serialization:implementing-java-serializable.adoc[`Serializable`] - xref:serialization:implementing-dataserializable.adoc[`DataSerializable`], and xref:serialization:implementing-dataserializable.adoc#identifieddataserializable[`IdentifiedDataSerializable`] formats, Only public fields and getters are available. A public field is available with its exact name. A getter is available with the JavaBean naming conventions.
- xref:serialization:implementing-portable-serialization.adoc[`Portable`] objects, the fields that are written in the `Portable.writePortable()` method are available using their exact names.
- All `HazelcastJsonValue` objects are available only if you create a mapping with the xref:integrate:map-connector.adoc[map connector].

NOTE: You cannot query nested object fields using SQL.

Consider a map that stores `Employee` objects as values with `name` and `age` fields:

```java
IMap<Long, Employee>
```

The SQL service has access to
the `Employee` object's fields.

[cols="1,1"]
|===
| Name
| Type

|`name`
|`VARCHAR`

|`age`
|`integer`
|===

Together with the key, you may query those fields.

[source,sql]
----
SELECT __key, this, name, age FROM employee
----

If both the key and value have fields with the same name, you may only query the key's field and not the value's field.

== Running Streaming Queries on Maps

At the moment, you cannot run streaming queries on maps with SQL.

Until this feature is available, use the Jet API to run streaming queries on maps. For a tutorial, see xref:pipelines:stream-imap.adoc[].

== Learn More

Learn the details of all the available xref:sql:sql-statements.adoc[SQL statements].

See more examples of the xref:sql:select.adoc[`SELECT` statement].



