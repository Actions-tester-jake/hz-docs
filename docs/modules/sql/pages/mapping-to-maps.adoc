= Creating a Mapping to a Hazelcast Map
:description: Before you can query data in maps, you may need to create a mapping with the map connector so that the SQL service knows how to access the entries in the most efficient way.
:page-aliases: sql:imap-connector.adoc

{description}

NOTE: With SQL, you cannot yet use maps as a streaming source or access them when they are stored in remote clusters.

== What is the Map Connector

The map connector allows you to create mappings to a distributed map in a local Hazelcast cluster. 

== Installing the Connector

This connector is included in Hazelcast.

== Map Security

If you use Hazelcast Enterprise, you can set up permissions to restrict clients' access to these data structures.

For example, to read from map sources, you must add the `create` and `read` permissions to those maps. If you use the map connector to write to map sinks, you must add the `create` and `put` permissions for those maps.

For details, see xref:security:native-client-security.adoc[].

== Configuration Options

To use the map connector in SQL, you must tell Hazelcast how to serialize/deserialize the keys and values, using the `keyFormat` and `valueFormat` options of the xref:sql:create-mapping.adoc[`CREATE MAPPING` statement].

As well as storing <<primitives, primitives>> in keys and values, you can also store objects by serializing them into one of the following formats:

* `portable`
* `json`
* `java` (Java serialization, `DataSerializable` or `IdentifiedDataSerializable`)

The key and value formats do not need to be the same.

=== Primitives

If you want to store one of the xref:data-types.adoc[primitive types] (any supported SQL data
type except `OBJECT`) in a map entry, the Java class
representing that type will be stored in the map.

For example, to create a mapping for `IMap<Integer, String>`, use:

```sql
CREATE MAPPING my_map
TYPE IMap
OPTIONS (
    'keyFormat'='int',
    'valueFormat'='varchar'
)
```

=== Portable Objects

xref:serialization:implementing-portable-serialization.adoc[`Portable` serialization] doesn't require a
custom Java class to be defined on the cluster, so it's ideal for
non-Java clients.

To use this format, you need to provide the following additional options:

* `keyPortableFactoryId`, `valuePortableFactoryId`
* `keyPortableClassId`, `valuePortableClassId`
* `keyPortableVersion`, `valuePortableVersion` (optional, default is `0`)

If you omit a column list from the `CREATE MAPPING` statement, Hazelcast will
resolve the column names and types by looking at the `ClassDefinition`
found using the given factory ID, class ID, and version.

If the `ClassDefinition` with the given IDs is not known to the cluster,
you must provide a column list so that Hazelcast can use it to create the `ClassDefinition`.

Example mapping where both key and value are `Portable`:

```sql
CREATE MAPPING my_map
TYPE IMap
OPTIONS (
    'keyFormat' = 'portable',
    'keyPortableFactoryId' = '123',
    'keyPortableClassId' = '456',
    'keyPortableVersion' = '0',  -- optional
    'valueFormat' = 'portable',
    'valuePortableFactoryId' = '123',
    'valuePortableClassId' = '789',
    'valuePortableVersion' = '0'  -- optional
)
```

For more information on `Portable` see xref:serialization:implementing-portable-serialization.adoc[].

=== JSON Objects

To store values in JSON, you must declare the field names in the column list. For example, here, we create a mapping to a distributed map that stores a JSON object with the `ticker` and `amount` fields.

```sql
CREATE MAPPING my_map(
    __key BIGINT,
    ticker VARCHAR,
    amount INT)
TYPE IMap
OPTIONS (
    'keyFormat' = 'bigint',
    'valueFormat' = 'json')
```

There are no additional options for this format.

By default, Hazelcast serializes JSON into `HazelcastJsonValue` objects, which allows you to query its fields.

JSON's type system doesn't match SQL's exactly. For example, JSON
numbers have unlimited precision, but such numbers are typically not
portable. We convert SQL integer and floating-point types into JSON
numbers. We convert the `DECIMAL` type, as well as all temporal types,
to JSON strings.

NOTE: Hazelcast doesn't yet support the `JSON` type from the SQL standard. As a result, you can't use functions like `JSON_VALUE` or `JSON_QUERY`.

=== Java Objects

Java serialization uses the
Java object exactly as `map.get()` returns it. You can use it for
objects serialized using the Java serialization or Hazelcast custom
serialization (`DataSerializable` or `IdentifiedDataSerializable`).

You must specify the name of the Java class into which you want to serialize data, using the `keyJavaClass` and
`valueJavaClass` options. For example:

```sql
CREATE MAPPING my_map
TYPE IMap
OPTIONS (
    'keyFormat' = 'java',
    'keyJavaClass' = 'java.lang.Long',
    'valueFormat' = 'java',
    'valueJavaClass' = 'com.example.Person')
```

If the Java class corresponds to one of the basic data types (numbers,
dates, strings), that type will directly be used for the key or value
and mapped as a column named `__key` for keys and `this` for values. In
the example above, the key will be mapped with the `BIGINT` type. In
fact, the above `keyFormat` and `keyJavaClass` duo is equivalent to
`'keyFormat'='bigint'`.

If the Java class is not one of the basic types:

- Hazelcast will analyze the class using reflection and use its properties as column names.
+
Hazelcast recognizes public fields and JavaBean-style getters. If some property has a non-primitive type, it will be mapped under the `OBJECT` type.
- The class must be available to the cluster.
+
You can either add the class to the
members' classpaths by creating a JAR file and adding it to the `lib`
directory, or you can use user code deployment. User code deployment
must be enabled on the members, see xref:clusters:deploying-code-from-clients.adoc[] for details.